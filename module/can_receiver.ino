/***************************************************************************
 * Программа для управления 7 сервоприводами через CAN-FD на модуле STM32.
 * Используется библиотека Servo для управления сервомоторами и специальная
 * конфигурация для CAN-FD (с номинальной скоростью 1 Mbps и скоростью передачи
 * данных 8 Mbps). Программа принимает пакет, содержащий 7 значений типа float,
 * по которым устанавливаются углы для обычных сервоприводов и скорость для
 * сервопривода с непрерывным вращением.
 ***************************************************************************/

// --------------------- Подключение библиотек ---------------------
#include <Servo.h>
#include <VBCoreG4_arduino_system.h>
#include <string.h>

// --------------------- Определение пинов для сервоприводов
// На порт PB0 подключен сервопривод 360
static const int servoPins[7] = {PA7, PC5, PC1, PC2, PC3, PA4, PB0};

// Массив объектов класса Servo для управления каждым из 7 сервоприводов.
Servo servoMotor[7];

// --------------------- Объявление переменных для CAN-FD ---------------------

FDCAN_HandleTypeDef *hfdcan1;
CanFD *canfd;
FDCAN_RxHeaderTypeDef RxHeader;

// --------------------- Функция setup() ---------------------
void setup() {
  // Инициализация последовательного порта для вывода отладочной информации
  // (скорость 115200 бод)
  Serial.begin(115200);
  pinMode(LED2, OUTPUT);

  // Настройка тактирования системы и инициализация CAN-FD
  SystemClock_Config(); // Конфигурация тактовой частоты микроконтроллера
  canfd = new CanFD();  // Создание нового объекта для управления CAN-FD
  canfd->init();        // Инициализация CAN-FD интерфейса

  // Задание параметров CAN-FD:
  //  - Номинальная скорость: 1 Mbps
  //  - Скорость передачи данных: 8 Mbps
  canfd->write_default_params(); // Применение стандартных параметров для CAN-FD
  canfd->apply_config();         // Применение конфигурации
  canfd->default_start();        // Запуск CAN-FD в стандартном режиме

  // Получение указателя на аппаратную конфигурацию CAN для дальнейшего
  // использования
  hfdcan1 = canfd->get_hfdcan();

  // Инициализация сервоприводов: привязываем каждый объект servoMotor к
  // соответствующему пину
  for (int i = 0; i < 7; i++) {
    servoMotor[i].attach(servoPins[i]);
  }

  Serial.println("CAN-FD receiver started. Servos attached.");
}

// --------------------- Основной цикл программы loop() ---------------------
void loop() {
  // Проверка: если во входном потоке для приёма сообщений есть данные,
  // выполняем обработку каждого сообщения в цикле.
  while (HAL_FDCAN_GetRxFifoFillLevel(hfdcan1, FDCAN_RX_FIFO0) > 0) {
    // Ожидаемый размер входящего сообщения: 7 значений типа float (7 * 4 байта
    // = 28 байт)
    const int length = 28;
    uint8_t rxData[length]; // Массив для хранения полученных байтов

    // Чтение сообщения из FIFO-буфера CAN
    if (HAL_FDCAN_GetRxMessage(hfdcan1, FDCAN_RX_FIFO0, &RxHeader, rxData) !=
        HAL_OK) {
      // Если чтение сообщения завершилось ошибкой, выводим сообщение об ошибке
      // и вызываем обработчик ошибок
      Serial.println("CAN receive error!");
      Error_Handler();
    } else {
      // Если сообщение успешно прочитано, проверяем идентификатор сообщения
      // Только сообщения с ID 0x700 обрабатываются нашим скриптом
      if (RxHeader.Identifier == 0x700) {
        // Распаковка полученных данных: копируем 28 байт в массив из 7
        // переменных типа float
        float servoValues[7];
        memcpy(servoValues, rxData, length);

        // Обработка значений для 6 обычных сервоприводов:
        // Каждое значение интерпретируется как угол (0..180 градусов)
        for (int i = 0; i < 6; i++) {
          float angle = servoValues[i];
          // Ограничение диапазона углов для безопасности: не ниже 0 и не выше
          // 180 градусов
          if (angle < 0.0f)
            angle = 0.0f;
          if (angle > 180.0f)
            angle = 180.0f;

          servoMotor[i].write(angle);
        }

        // Обработка седьмого сервопривода, рассчитанного на непрерывное
        // вращение: Значение ~90 означает остановку, значения меньше 90 –
        // вращение в одну сторону, значения больше 90 – вращение в другую
        // сторону.
        float speed = servoValues[6];
        // Ограничение диапазона скорости в пределах 0 и 180
        if (speed < 0.0f)
          speed = 0.0f;
        if (speed > 180.0f)
          speed = 180.0f;
        servoMotor[6].write(speed);

        // (Опционально) Вывод значений полученных сервоприводов в Serial
        // Monitor для отладки.
        Serial.print("Got servo values: ");
        for (int i = 0; i < 7; i++) {
          Serial.print(servoValues[i], 1);
          Serial.print(i < 6 ? ", " : "\n");
        }
      }
    }
  }

  // Небольшая задержка 10 мс для обеспечения стабильности работы и
  // предотвращения перегрузки контроллера
  delay(10);
}